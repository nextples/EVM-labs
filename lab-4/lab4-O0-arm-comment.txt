swap:
        sub     sp, sp, #32 		//записываем sp-32 в sp (резервация памяти в стеке)
        str     x0, [sp, 8]		//записываем &a в стек по адресу sp+8
        str     x1, [sp]		//записываем &b в стек по адресу sp
        ldr     x0, [sp, 8]		//записываем &a в регистр x0 (tmp)
        ldr     w0, [x0]		//записываем a(tmp) в регистр w0
        str     w0, [sp, 28]		//записываем a в стек по адресу sp+28
        ldr     x0, [sp]		//записываем &b в регистр x0
        ldr     w1, [x0]		//записываем b в регистр w1
        ldr     x0, [sp, 8]		//записываем &a в регистр x0
        str     w1, [x0]		//записываем b в &a
        ldr     x0, [sp]		//записываем &b в регистр x0
        ldr     w1, [sp, 28]		//записываем a в регистр w1
        str     w1, [x0]		//записываем a в &b
        nop
        add     sp, sp, 32		//sp = sp+32 (стираем стек, использованный в функции)
        ret				//считываем адрес команды из регистра x30 и записываем в регистр PC - счетчик команд
FillArray:
        stp     x29, x30, [sp, -48]!	//записываем сначала значение из x29(фрейм стека), затем из x30(адрес возврата) по адресу [sp-48] затем по адресу [sp - 48 -8]
        mov     x29, sp			//записываем sp в x29
        str     x0, [sp, 24]		//записываем 140000 в стек по адресу sp+24
        ldr     x0, [sp, 24]		//записываем 140000 в регистр x0 (1ый аргумент calloc)
        mov     x1, 4			//записываем 4 в регистр x1 (2ой аргумент calloc)
        bl      calloc
        str     x0, [sp, 32]		//записываем &array в стек по адресу sp+32
        str     wzr, [sp, 44]		//записываем регистр wzr(будет храниться i) в стек по адресу sp+44
        b       .L3
.L4:
        bl      rand			//вызываем rand
        mov     w1, w0			//записываем w0(рандомное число) в регистр w1
        ldrsw   x0, [sp, 44]		//записываем i в регистр x0
        lsl     x0, x0, 2		//записываем i*4 в регистр x0	[логический сдвиг влево]
        ldr     x2, [sp, 32]		//записываем &array в регистр x2
        add     x2, x2, x0		//записываем &array[i] в регистр x2
        mov     w0, 19923		//записываем 19923 в регистр w0
        movk    w0, 0x1062, lsl 16	//записываем 1062 в 16-31 биты регистра w0 (получим: 69 619 155)
        smull   x0, w1, w0		//знаковое умножение 32-битных чисел, запись в 64-битный регистр; x0 = rand * 69 619 155
        lsr     x0, x0, 32		//[логический сдвиг вправо] (сохраняем 32-64 биты на место 0-31, вместо 32-64 пишем 0)
        asr     w3, w0, 6		//[арифметический сдвиг вправо] 
        asr     w0, w1, 31
        sub     w0, w3, w0		/*	 получение числа rand()%1000	 */
        mov     w3, 1000		
        mul     w0, w0, w3
        sub     w0, w1, w0
        str     w0, [x2]		//записываем rand() % 1000 в array[j]
        ldr     w0, [sp, 44]		//записываем i в регистр w0
        add     w0, w0, 1		//i++
        str     w0, [sp, 44]		//записываем i в стек по адресу sp+44
.L3:
        ldrsw   x0, [sp, 44]		//записываем i в регистр x0
        ldr     x1, [sp, 24]		//записываем 140000 в регистр x1
        cmp     x1, x0			
        bgt     .L4			//переход если i < 140000
        ldr     x0, [sp, 32]		//записываем &array в регистр x0
        ldp     x29, x30, [sp], 48	//sp = sp + 48; записываем sp в регистры x29 и x30
        ret				//считываем адрес команды из регистра x30 и записываем в регистр PC - счетчик команд
main:
        stp     x29, x30, [sp, -48]!	//записываем сначала значение из x29(фрейм стека), затем из x30(адрес возврата) по адресу [sp] затем по адресу [sp - 48]
        mov     x29, sp			//записываем sp в регистр x29
        mov     x0, 8928		//записываем 8928 в регистр x0
        movk    x0, 0x2, lsl 16		//записываем число 0x2 в 16-32 биты регистра x0
        str     x0, [sp, 32]		//записываем x0 (140000) в стек по адресу[sp+32];
        ldr     x0, [sp, 32]		//записываем 140000 в регистр x0; 
        bl      FillArray		//вызываем FillArray; записываем в x30 адрес возврата (следующая строка)
        str     x0, [sp, 24]		//записываем &array по адресу [sp+24]
        str     wzr, [sp, 44]		//записываем 0(i) по адресу [sp+44]
        b       .L7			//переходим к L7; записываем в x30 адрес возврата
.L11:
        str     wzr, [sp, 40]		//записываем 0(j) по адресу [sp+40]
        b       .L8			//переходим к L8; записываем в x30 адрес возврата
.L10: 	//if + swap
        ldrsw   x0, [sp, 40]		//записываем j в регистр x0
        lsl     x0, x0, 2		//эквивалентно (MOV X0, X0, LSL 2) - побитовый сдвиг влево на 2 (умножение на 4)
        ldr     x1, [sp, 24]		//записываем &array в регистр x1
        add     x0, x1, x0		//записываем в x0 значение x1+x0(&array + 4*j)
        ldr     w1, [x0]		//записываем array[j] в регистр w1
        ldrsw   x0, [sp, 40]		//записываем j в регистр x0
        add     x0, x0, 1		//j + 1
        lsl     x0, x0, 2		//записываем (j+1) * 4 в регистр x0
        ldr     x2, [sp, 24]		//записываем &array в регистр x2
        add     x0, x2, x0		//записываем в x0 значение x2+x0(&array + 4*(j+1))
        ldr     w0, [x0]		//записываем array[j+1] в регистр w0
        cmp     w1, w0
        ble     .L9			//переход если array[j] < array[j+1]
        ldrsw   x0, [sp, 40]		//записываем j в регистр x0
        lsl     x0, x0, 2		//записываем j*4 в регистр x0
        ldr     x1, [sp, 24]		//записываем &array в регистр x1
        add     x2, x1, x0		//записываем &array[j] в регистр x2
        ldrsw   x0, [sp, 40]		//записываем j в регистр x0
        add     x0, x0, 1		//записываем j+1 в регистр x0
        lsl     x0, x0, 2		//записываем (j+1)*4 в регистр x0
        ldr     x1, [sp, 24]		//записываем &array в регистр x1
        add     x0, x1, x0		//записываем &array[j+1] в регистр x0
        mov     x1, x0			//записываем &array[j+1] в регистр x1
        mov     x0, x2			//записываем &array[j] в регистр x0
        bl      swap			//записывает адрес возврата в регистр x30, переходит по адресу swap
.L9: 	//j++
        ldr     w0, [sp, 40] 		//записываем j в регистр w0
        add     w0, w0, 1		//j++
        str     w0, [sp, 40]		//записываем j по адресу sp+40
.L8:
        ldrsw   x1, [sp, 40]		//записываем в j в регистр x1 
        ldr     x0, [sp, 32]		//записываем 140000 в регистр x0
        sub     x0, x0, #1		//записываем x0-1 в регистр x0
        cmp     x1, x0			//j < 140000 - 1
        blt     .L10			//переход если j < 139999
        ldr     w0, [sp, 44]		//записываем i в регистр w0
        add     w0, w0, 1		//i++
        str     w0, [sp, 44]		//записываем i в стек по адресу sp+44
.L7: for; (i < n)
        ldrsw   x0, [sp, 44] 		//записываем i в регистр x0 (запись со знаковым расширением 32 бита -> 64 бита)
        ldr     x1, [sp, 32]		//записываем 140000 в регистр x1
        cmp     x1, x0			//i < n 
        bgt     .L11			//переход если i < 140000; записываем в x30 адрес возврата
        mov     w0, 0			//записываем 0 в регистр w0
        ldp     x29, x30, [sp], 48	//sp = sp + 48; записываем sp в регистры x29 и x30
        ret				//считываем адрес команды из регистра x30 и записываем в регистр PC - счетчик команд